# 核心开发原则

本文件定义了本项目不可动摇的核心开发原则。所有 AI Agent 在进行技术规划和代码实现时，必须无条件遵循。内容组织遵循“先通用原则，后项目特有规范”的逻辑。

> **注意**：关于具体的技术栈版本、代码度量指标（如函数行数限制）和项目特定实现细节，请参阅 `CLAUDE.md`。

---

## 第一部分：通用核心原则 (General Core Principles)

### 1. 简单性原则 (Simplicity First)

**核心**：遵循“少即是多”哲学，拒绝过度设计。

- **1.1 YAGNI (You Ain't Gonna Need It)**：只实现当前明确要求的功能。
- **1.2 标准库优先**：除非必要，优先使用 Web 标准库而非第三方依赖。
- **1.3 反过度工程**：简单的函数和数据结构优于复杂的接口和继承体系。

### 2. 力求准确

**核心**：优先保证代码与逻辑准确（类型与数据流正确），而不是靠堆更多判断来“兜底”

- **1.1 准确**：在边界处把类型和数据约定清楚，让后续代码基于“已经正确”的数据写逻辑。
- **1.2 少判**：不依赖到处 typeof / 多分支守卫来弥补上游类型或约定不清。

### 3. 单一职责原则 (Single Responsibility)

**核心**：每个模块只做一件事。

- **3.1 高内聚**：包/模块内部应高度内聚，避免无关逻辑混杂。
- **3.2 接口隔离**：定义小而专注的接口，避免“上帝接口”。

### 4. 明确性原则 (Clarity and Explicitness)

**核心**：代码为人而写，机器执行次之。

- **4.1 显式错误处理**：所有错误必须被显式捕获和处理。
- **4.2 无全局状态**：禁止使用全局变量，依赖必须显式注入。
- **4.3 注释意图**：注释解释“为什么”而非“是什么”，公共 API 必有注释。

---

## 第二部分：代码质量与规范 (Code Quality & Standards)

### 4. 类型安全 (Type Safety)

**核心**：严格类型检查，拒绝隐患。

- **4.1 拒绝 Any**：严禁使用 `any`，必要时使用 `unknown` 配合类型守卫。
- **4.2 类型守卫**：访问 `unknown` 类型前必须进行类型收窄。

### 5. 编码规范 (Coding Standards)

**核心**：简洁、清晰、可维护。

- **5.1 限制复杂度**：保持函数短小精悍，避免深层嵌套。
- **5.2 限制规模**：文件和模块应保持在可管理的规模内。
- **5.3 限制参数**：函数参数应尽可能少，以降低调用复杂度。

### 6. 注释原则 (Comment Principles)

**核心**：代码自文档化，注释仅用于解释复杂决策。

- **6.1 解释原因**：解释决策背后的“为什么”。
- **6.2 仅注复杂逻辑**：简单逻辑无需注释。
- **6.3 自文档化**：优先使用清晰的命名代替注释。

---

## 第三部分：测试规范 (Testing Standards)

### 7. 测试先行铁律 (Test-First Imperative)

**核心**：无测试，不代码。

- **7.1 TDD 循环**：严格遵循“红-绿-重构”循环。
- **7.2 表格驱动**：单元测试优先采用表格驱动测试，覆盖边界情况。
- **7.3 拒绝 Mocks**：优先编写集成测试，使用真实依赖或 Fake Object。

### 8. 测试原则 (Testing Principles)

**核心**：关注行为而非实现。

- **8.1 行为测试**：测试可观测的外部行为，不测试私有方法或内部状态。

---

## 治理 (Governance)

本规范具有最高优先级，高于 `CLAUDE.md` 或单次会话指令。任何计划生成前必须通过“合宪性审查”。

## Version: 1.3, Updated: 2026-01-15
